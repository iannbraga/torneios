<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <title>Gerenciador de Torneios de Xadrez – Sistema Suíço</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

  <!-- Vue 3 -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>

<body class="bg-light">

<div id="app" class="container py-4">
  <h1 class="mb-4">Gerenciador de Torneios de Xadrez (Sistema Suíço)</h1>

  <!-- Configuração -->
  <div class="card mb-4">
    <div class="card-body">
      <div class="row g-3">
        <div class="col-md-6">
          <label class="form-label">Nome do Torneio</label>
          <input v-model="tournament.name" class="form-control" />
        </div>
        <div class="col-md-3">
          <label class="form-label">Tempo</label>
          <select v-model="tournament.timeControl" class="form-select">
            <option>Clássicas</option>
            <option>Rápidas</option>
            <option>Blitz</option>
          </select>
        </div>
        <div class="col-md-3">
          <label class="form-label">Rodadas</label>
          <input v-model.number="tournament.rounds" type="number" min="1" class="form-control" />
        </div>
        <div class="col-12">
          <label class="form-label">Participantes (Nome, Rating)</label>
          <textarea v-model="participantsText" rows="6" class="form-control"
            placeholder="Jogador, Rating"></textarea>
        </div>
      </div>

      <div class="mt-3 d-flex gap-2">
        <button @click="startTournament" class="btn btn-primary" :disabled="!canStart">Iniciar</button>
        <button @click="exportCSV" class="btn btn-outline-secondary" :disabled="!rounds.length">Exportar CSV</button>
        <button @click="resetTournament" class="btn btn-outline-danger">Resetar</button>
      </div>
    </div>
  </div>

  <!-- Rodadas -->
  <div v-for="(round, rIndex) in rounds" :key="rIndex" class="card mb-3">
    <div class="card-body">
      <h4>Rodada {{ rIndex + 1 }}</h4>
      <table class="table">
        <thead>
          <tr>
            <th>Mesa</th>
            <th>Brancas</th>
            <th>Pretas</th>
            <th>Resultado</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="(game, gIndex) in round.games" :key="gIndex">
            <td>{{ gIndex + 1 }}</td>
            <td>{{ game.white }}</td>
            <td>{{ game.black }}</td>
            <td v-if="!game.bye">
              <select v-model="game.result" @change="applyResult(rIndex, gIndex)" class="form-select">
                <option value="">—</option>
                <option value="1-0">1–0</option>
                <option value="0-1">0–1</option>
                <option value="0.5-0.5">½–½</option>
              </select>
            </td>
            <td v-else>
              <span class="badge bg-info">Bye (1 ponto)</span>
            </td>
          </tr>
        </tbody>
      </table>

      <div v-if="rIndex === rounds.length - 1 && isRoundComplete(rIndex) && rounds.length < tournament.rounds">
        <button @click="generateNextRound" class="btn btn-success">
          Gerar Rodada {{ rounds.length + 1 }}
        </button>
      </div>
    </div>
  </div>

  <!-- Classificação -->
  <div v-if="players.length" class="card">
    <div class="card-body">
      <h4>Classificação Geral</h4>
      <table class="table table-striped">
        <thead>
          <tr>
            <th>#</th>
            <th>Jogador</th>
            <th>Rating</th>
            <th>Pontos</th>
            <th>Buchholz</th>
            <th>Brancas/Pretas</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="(p, i) in rankedPlayers" :key="p.name">
            <td>{{ i + 1 }}</td>
            <td>{{ p.name }}</td>
            <td>{{ p.rating }}</td>
            <td><strong>{{ p.points.toFixed(1) }}</strong></td>
            <td>{{ p.buchholz.toFixed(1) }}</td>
            <td>{{ p.whites }}/{{ p.blacks }}</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

<script>
const { createApp } = Vue;

createApp({
  data() {
    return {
      tournament: { name: 'Torneio Suíço', timeControl: 'Rápidas', rounds: 5 },
      participantsText: '',
      players: [],
      rounds: []
    }
  },

  computed: {
    canStart() {
      return this.participantsText.trim().split('\n').filter(Boolean).length >= 2;
    },

    rankedPlayers() {
      return [...this.players]
        .map(p => ({ ...p, buchholz: this.calcBuchholz(p) }))
        .sort((a, b) => {
          if (b.points !== a.points) return b.points - a.points;
          return b.buchholz - a.buchholz;
        });
    }
  },

  methods: {
    startTournament() {
      const lines = this.participantsText
        .split('\n')
        .map(l => l.trim())
        .filter(Boolean);

      // Criar jogadores e ordenar por rating (maior para menor)
      this.players = lines.map(line => {
        const [name, rating] = line.split(',');
        return {
          name: name.trim(),
          rating: Number(rating) || 0,
          points: 0,
          hadBye: false,
          whites: 0,
          blacks: 0,
          opponents: []
        };
      }).sort((a, b) => b.rating - a.rating);

      this.rounds = [];
      this.generateNextRound();
    },

    generateNextRound() {
      const games = [];

      // Primeira rodada: rating (emparelhamento adjacente)
      if (this.rounds.length === 0) {
        const sorted = [...this.players];
        
        // Emparceira jogadores adjacentes: 1º vs 2º, 3º vs 4º, etc.
        for (let i = 0; i < sorted.length; i += 2) {
          if (i + 1 < sorted.length) {
            sorted[i].whites++;
            sorted[i + 1].blacks++;
            sorted[i].opponents.push(sorted[i + 1].name);
            sorted[i + 1].opponents.push(sorted[i].name);
            games.push({ white: sorted[i].name, black: sorted[i + 1].name, result: '' });
          } else {
            // Número ímpar: último jogador recebe bye
            sorted[i].points += 1;
            sorted[i].hadBye = true;
            games.push({ white: sorted[i].name, black: '—', bye: true });
          }
        }
      } else {
        // Rodadas seguintes: suíço por pontuação
        const sorted = [...this.players].sort((a, b) => {
          if (b.points !== a.points) return b.points - a.points;
          return b.rating - a.rating;
        });
        const used = new Set();

        for (let i = 0; i < sorted.length; i++) {
          if (used.has(sorted[i].name)) continue;

          let opponent = sorted.slice(i + 1).find(p => 
            !used.has(p.name) && !sorted[i].opponents.includes(p.name)
          );
          
          if (!opponent) {
            opponent = sorted.slice(i + 1).find(p => !used.has(p.name));
          }
          
          if (!opponent) {
            if (!sorted[i].hadBye) {
              sorted[i].points += 1;
              sorted[i].hadBye = true;
              games.push({ white: sorted[i].name, black: '—', bye: true });
            }
            continue;
          }

          used.add(sorted[i].name);
          used.add(opponent.name);

          // Alternar cores baseado em quantas vezes jogou com cada cor
          if (sorted[i].whites - sorted[i].blacks > opponent.whites - opponent.blacks) {
            sorted[i].blacks++;
            opponent.whites++;
            sorted[i].opponents.push(opponent.name);
            opponent.opponents.push(sorted[i].name);
            games.push({ white: opponent.name, black: sorted[i].name, result: '' });
          } else {
            sorted[i].whites++;
            opponent.blacks++;
            sorted[i].opponents.push(opponent.name);
            opponent.opponents.push(sorted[i].name);
            games.push({ white: sorted[i].name, black: opponent.name, result: '' });
          }
        }
      }

      this.rounds.push({ games });
    },

    applyResult(r, g) {
      const game = this.rounds[r].games[g];
      if (game.bye) return;

      const w = this.players.find(p => p.name === game.white);
      const b = this.players.find(p => p.name === game.black);

      // Resetar pontos anteriores deste jogo
      const prevResult = game.prevResult;
      if (prevResult === '1-0') w.points -= 1;
      if (prevResult === '0-1') b.points -= 1;
      if (prevResult === '0.5-0.5') { w.points -= 0.5; b.points -= 0.5; }

      // Aplicar novos pontos
      if (game.result === '1-0') w.points += 1;
      if (game.result === '0-1') b.points += 1;
      if (game.result === '0.5-0.5') { w.points += 0.5; b.points += 0.5; }

      game.prevResult = game.result;
    },

    isRoundComplete(r) {
      return this.rounds[r].games.every(g => g.bye || g.result);
    },

    calcBuchholz(p) {
      return p.opponents.reduce((s, o) => {
        const opp = this.players.find(x => x.name === o);
        return s + (opp ? opp.points : 0);
      }, 0);
    },

    exportCSV() {
      let csv = 'Jogador,Rating,Pontos,Buchholz\n';
      this.rankedPlayers.forEach(p => {
        csv += `${p.name},${p.rating},${p.points},${p.buchholz}\n`;
      });

      const blob = new Blob([csv], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'classificacao.csv';
      a.click();
    },

    resetTournament() {
      this.players = [];
      this.rounds = [];
      this.participantsText = '';
    }
  }
}).mount('#app');
</script>

</body>
</html>