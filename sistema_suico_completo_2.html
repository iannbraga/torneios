<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <title>Gerenciador de Torneios de Xadrez – Sistema Suíço</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

  <!-- Vue 3 -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>

<body class="bg-light">

  <div id="app" class="container py-4">
    <h1 class="mb-4">Gerenciador de Torneios de Xadrez (Sistema Suíço)</h1>

    <!-- Configuração -->
    <div class="card mb-4">
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Nome do Torneio</label>
            <input v-model="tournament.name" class="form-control" />
          </div>
          <div class="col-md-3">
            <label class="form-label">Tempo</label>
            <select v-model="tournament.timeControl" class="form-select">
              <option>Clássicas</option>
              <option>Rápidas</option>
              <option>Blitz</option>
            </select>
          </div>
          <div class="col-md-3">
            <label class="form-label">Rodadas</label>
            <input v-model.number="tournament.rounds" type="number" min="1" class="form-control" />
          </div>
          <div class="col-12">
            <label class="form-label">Participantes (1 por linha)</label>
            <textarea v-model="participantsText" rows="4" class="form-control"></textarea>
          </div>
        </div>

        <div class="mt-3 d-flex gap-2">
          <button @click="startTournament" class="btn btn-primary" :disabled="!canStart">Iniciar</button>
          <button @click="exportCSV" class="btn btn-outline-secondary" :disabled="!rounds.length">Exportar CSV</button>
          <button @click="resetTournament" class="btn btn-outline-danger">Resetar</button>
        </div>
      </div>
    </div>

    <!-- Rodadas -->
    <div v-for="(round, rIndex) in rounds" :key="rIndex" class="card mb-3">
      <div class="card-body">
        <h4>Rodada {{ rIndex + 1 }}</h4>
        <table class="table">
          <thead>
            <tr>
              <th>Mesa</th>
              <th>Brancas</th>
              <th>Pretas</th>
              <th>Resultado</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(game, gIndex) in round.games" :key="gIndex">
              <td>{{ gIndex + 1 }}</td>
              <td>{{ game.white }}</td>
              <td>{{ game.black }}</td>
              <td v-if="!game.bye">
                <select v-model="game.result" @change="applyResult(rIndex, gIndex)" class="form-select">
                  <option value="">—</option>
                  <option value="1-0">1–0</option>
                  <option value="0-1">0–1</option>
                  <option value="0.5-0.5">½–½</option>
                </select>
              </td>
              <td v-else><span class="badge bg-info">Bye (1 ponto)</span></td>
            </tr>
          </tbody>
        </table>
        <div v-if="rIndex === rounds.length - 1 && !isRoundComplete(rIndex)" class="alert alert-warning">
          Aguardando resultados desta rodada
        </div>
        <div v-if="rIndex === rounds.length - 1 && isRoundComplete(rIndex) && rounds.length < tournament.rounds"
          class="mt-3">
          <button @click="generateNextRound" class="btn btn-success">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
              class="bi bi-plus-circle me-1" viewBox="0 0 16 16">
              <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z" />
              <path
                d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" />
            </svg>
            Gerar Rodada {{ rounds.length + 1 }}
          </button>
        </div>
      </div>
    </div>

    <!-- Classificação -->
    <div v-if="players.length" class="card">
      <div class="card-body">
        <h4>Classificação Geral</h4>
        <table class="table table-striped">
          <thead>
            <tr>
              <th>#</th>
              <th>Jogador</th>
              <th>Pontos</th>
              <th>Buchholz</th>
              <th>Brancas/Pretas</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(p, i) in rankedPlayers" :key="p.name">
              <td>{{ i + 1 }}</td>
              <td>{{ p.name }}</td>
              <td><strong>{{ p.points.toFixed(1) }}</strong></td>
              <td>{{ p.buchholz.toFixed(1) }}</td>
              <td>{{ p.whites }}/{{ p.blacks }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          tournament: { name: 'Torneio Suíço', timeControl: 'Rápidas', rounds: 5 },
          participantsText: '',
          players: [],
          rounds: []
        }
      },
      computed: {
        canStart() {
          return this.participantsText.trim().split('\n').filter(Boolean).length >= 2;
        },
        rankedPlayers() {
          return [...this.players]
            .map(p => ({ ...p, buchholz: this.calcBuchholz(p) }))
            .sort((a, b) => {
              if (b.points !== a.points) return b.points - a.points;
              return b.buchholz - a.buchholz;
            });
        }
      },
      methods: {
        shuffle(array) {
          const arr = [...array];
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        },

        startTournament() {
          const names = this.participantsText
            .split('\n')
            .map(p => p.trim())
            .filter(Boolean);

          if (names.length < 2) {
            alert('É necessário pelo menos 2 participantes');
            return;
          }

          this.players = names.map(name => ({
            name,
            points: 0,
            hadBye: false,
            whites: 0,
            blacks: 0,
            colorHistory: [],
            opponents: []
          }));

          this.rounds = [];
          this.generateNextRound();
        },
        generateNextRound() {
          if (this.rounds.length >= this.tournament.rounds) return;

          const games = [];
          const paired = new Set();

          // 1️⃣ Agrupar por pontuação
          const scoreGroups = {};
          this.players.forEach(p => {
            if (!scoreGroups[p.points]) scoreGroups[p.points] = [];
            scoreGroups[p.points].push(p);
          });

          // Ordenar grupos (maior pontuação primeiro)
          const orderedScores = Object.keys(scoreGroups)
            .map(Number)
            .sort((a, b) => b - a);

          let floaters = [];

          // 2️⃣ Processar grupos
          orderedScores.forEach(score => {
            let group = [...floaters, ...scoreGroups[score]];
            floaters = [];

            // Ordenar dentro do grupo (menos cores jogadas primeiro)
            group.sort((a, b) =>
              (a.whites + a.blacks) - (b.whites + b.blacks)
            );

            // Se ímpar, flutua o último
            if (group.length % 2 === 1) {
              floaters.push(group.pop());
            }

            // Emparceirar dentro do grupo
            for (let i = 0; i < group.length; i += 2) {
              const p1 = group[i];
              const p2 = group[i + 1];

              if (!p2) continue;

              // Preferência de cores (não obrigatória)
              let white = p1;
              let black = p2;

              const p1Diff = p1.whites - p1.blacks;
              const p2Diff = p2.whites - p2.blacks;

              if (p1Diff > p2Diff) {
                white = p2; black = p1;
              }

              white.whites++;
              black.blacks++;
              white.colorHistory.push('white');
              black.colorHistory.push('black');

              white.opponents.push(black.name);
              black.opponents.push(white.name);

              paired.add(white.name);
              paired.add(black.name);

              games.push({
                white: white.name,
                black: black.name,
                result: '',
                bye: false,
                applied: false
              });
            }
          });

          // 3️⃣ Bye (se sobrou alguém)
          if (floaters.length === 1) {
            const byePlayer = floaters[0];
            byePlayer.points += 1;
            byePlayer.hadBye = true;

            games.push({
              white: byePlayer.name,
              black: '—',
              result: '1-0',
              bye: true,
              applied: true
            });
          }

          this.rounds.push({ games });
        },

        generateNextRound() {
          if (this.rounds.length >= this.tournament.rounds) {
            return;
          }

          let sorted;

          if (this.rounds.length === 0) {
            // Primeira rodada: embaralhar aleatoriamente
            sorted = this.shuffle(this.players);
          } else {
            // Rodadas seguintes: agrupar por pontuação
            sorted = [...this.players].sort((a, b) => {
              if (b.points !== a.points) return b.points - a.points;
              return b.whites + b.blacks - (a.whites + a.blacks);
            });
          }

          const games = [];
          const paired = new Set();

          // Verificar se há número ímpar de jogadores
          if (sorted.length % 2 === 1) {
            // Encontrar jogador elegível para bye (que ainda não teve)
            let byePlayer = null;

            // Procurar de baixo para cima (menor pontuação primeiro)
            for (let i = sorted.length - 1; i >= 0; i--) {
              if (!sorted[i].hadBye) {
                byePlayer = sorted[i];
                break;
              }
            }

            // Se todos já tiveram bye, dar para quem teve há mais tempo
            if (!byePlayer) {
              byePlayer = sorted[sorted.length - 1];
            }

            byePlayer.points += 1;
            byePlayer.hadBye = true;
            paired.add(byePlayer.name);
            games.push({
              white: byePlayer.name,
              black: '—',
              result: '1-0',
              bye: true,
              applied: true
            });
          }

          // Emparceirar jogadores
          for (let i = 0; i < sorted.length; i++) {
            if (paired.has(sorted[i].name)) continue;

            const p1 = sorted[i];
            let p2 = null;

            // Procurar oponente mais próximo em pontuação que ainda não jogou contra
            for (let j = i + 1; j < sorted.length; j++) {
              if (paired.has(sorted[j].name)) continue;
              if (!p1.opponents.includes(sorted[j].name)) {
                p2 = sorted[j];
                break;
              }
            }

            // Se não encontrou, procurar qualquer oponente disponível
            if (!p2) {
              for (let j = i + 1; j < sorted.length; j++) {
                if (paired.has(sorted[j].name)) continue;
                p2 = sorted[j];
                break;
              }
            }

            if (!p2) continue;

            // Determinar cores - ALTERNÂNCIA ESTRITA
            let white = null;
            let black = null;

            const p1LastColor = p1.colorHistory[p1.colorHistory.length - 1];
            const p2LastColor = p2.colorHistory[p2.colorHistory.length - 1];

            // Regra de alternância estrita
            if (p1LastColor === 'white') {
              // p1 DEVE jogar de pretas
              white = p2;
              black = p1;
            } else if (p1LastColor === 'black') {
              // p1 DEVE jogar de brancas
              white = p1;
              black = p2;
            } else if (p2LastColor === 'white') {
              // p2 DEVE jogar de pretas
              white = p1;
              black = p2;
            } else if (p2LastColor === 'black') {
              // p2 DEVE jogar de brancas
              white = p2;
              black = p1;
            } else {
              // Primeira rodada - balancear pelo total
              const p1Diff = p1.whites - p1.blacks;
              const p2Diff = p2.whites - p2.blacks;

              if (p1Diff > p2Diff) {
                white = p2; black = p1;
              } else if (p2Diff > p1Diff) {
                white = p1; black = p2;
              } else {
                // Totalmente balanceado - melhor ranqueado joga de brancas
                white = p1; black = p2;
              }
            }

            white.whites++;
            black.blacks++;
            white.colorHistory.push('white');
            black.colorHistory.push('black');
            white.opponents.push(black.name);
            black.opponents.push(white.name);

            paired.add(white.name);
            paired.add(black.name);

            games.push({
              white: white.name,
              black: black.name,
              result: '',
              bye: false,
              applied: false
            });
          }

          this.rounds.push({ games });
        },

        applyResult(roundIndex, gameIndex) {
          const game = this.rounds[roundIndex].games[gameIndex];

          if (game.bye) return;

          const white = this.players.find(p => p.name === game.white);
          const black = this.players.find(p => p.name === game.black);

          if (!white || !black) return;

          // Remover pontos anteriores se já havia sido aplicado
          if (game.applied) {
            if (game.previousResult === '1-0') {
              white.points -= 1;
            } else if (game.previousResult === '0-1') {
              black.points -= 1;
            } else if (game.previousResult === '0.5-0.5') {
              white.points -= 0.5;
              black.points -= 0.5;
            }
          }

          // Aplicar novos pontos
          if (game.result === '1-0') {
            white.points += 1;
          } else if (game.result === '0-1') {
            black.points += 1;
          } else if (game.result === '0.5-0.5') {
            white.points += 0.5;
            black.points += 0.5;
          }

          game.previousResult = game.result;
          game.applied = game.result !== '';
        },

        isRoundComplete(roundIndex) {
          const round = this.rounds[roundIndex];
          return round.games.every(g => g.bye || (g.result && g.applied));
        },

        calcBuchholz(player) {
          return player.opponents.reduce((sum, oppName) => {
            const opp = this.players.find(p => p.name === oppName);
            return sum + (opp ? opp.points : 0);
          }, 0);
        },

        exportCSV() {
          let csv = 'Rodada,Mesa,Brancas,Pretas,Resultado\n';
          this.rounds.forEach((round, rIndex) => {
            round.games.forEach((game, gIndex) => {
              const result = game.bye ? 'BYE' : (game.result || 'Pendente');
              csv += `${rIndex + 1},${gIndex + 1},${game.white},${game.black},${result}\n`;
            });
          });

          csv += '\n\nClassificação Final\n';
          csv += 'Posição,Jogador,Pontos,Buchholz\n';
          this.rankedPlayers.forEach((p, i) => {
            csv += `${i + 1},${p.name},${p.points.toFixed(1)},${p.buchholz.toFixed(1)}\n`;
          });

          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `${this.tournament.name || 'torneio'}.csv`;
          a.click();
        },

        resetTournament() {
          if (confirm('Tem certeza que deseja resetar o torneio?')) {
            this.tournament = { name: 'Torneio Suíço', timeControl: 'Rápidas', rounds: 5 };
            this.participantsText = '';
            this.players = [];
            this.rounds = [];
          }
        }
      }
    }).mount('#app');
  </script>

</body>

</html>