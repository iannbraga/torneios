<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <title>Gerenciador de Torneios de Xadrez – Sistema Suíço Avançado</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

  <!-- Vue 3 -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>

<body class="bg-light">

  <div id="app" class="container py-4">
    <h1 class="mb-4">Gerenciador de Torneios de Xadrez (Suíço Avançado)</h1>

    <!-- Configuração -->
    <div class="card mb-4">
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Nome do Torneio</label>
            <input v-model="tournament.name" class="form-control" />
          </div>
          <div class="col-md-3">
            <label class="form-label">Tempo</label>
            <select v-model="tournament.timeControl" class="form-select">
              <option>Clássicas</option>
              <option>Rápidas</option>
              <option>Blitz</option>
            </select>
          </div>
          <div class="col-md-3">
            <label class="form-label">Rodadas</label>
            <input v-model.number="tournament.rounds" type="number" min="1" class="form-control" />
          </div>
          <div class="col-12">
            <label class="form-label">Participantes (1 por linha)</label>
            <textarea v-model="participantsText" rows="4" class="form-control"></textarea>
          </div>
        </div>

        <div class="mt-3 d-flex gap-2">
          <button @click="startTournament" class="btn btn-primary">Iniciar</button>
          <button @click="exportCSV" class="btn btn-outline-secondary">Exportar CSV</button>
          <button @click="resetTournament" class="btn btn-outline-danger">Resetar</button>
        </div>
      </div>
    </div>

    <!-- Rodadas -->
    <div v-for="(round, rIndex) in rounds" :key="rIndex" class="card mb-3">
      <div class="card-body">
        <h4>Rodada {{ rIndex + 1 }}</h4>
        <table class="table">
          <thead>
            <tr>
              <th>Brancas</th>
              <th>Pretas</th>
              <th>Resultado</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(game, gIndex) in round.games" :key="gIndex">
              <td>{{ game.white }}</td>
              <td>{{ game.black }}</td>
              <td v-if="!game.bye">
                <select v-model="game.result" @change="applyResult(game)" class="form-select">
                  <option value="">—</option>
                  <option value="1-0">1–0</option>
                  <option value="0-1">0–1</option>
                  <option value="0.5-0.5">½–½</option>
                </select>
              </td>
              <td v-else>Bye (1 ponto)</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Classificação -->
    <div v-if="players.length" class="card">
      <div class="card-body">
        <h4>Classificação</h4>
        <table class="table table-striped">
          <thead>
            <tr>
              <th>#</th>
              <th>Jogador</th>
              <th>Pontos</th>
              <th>Buchholz</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(p, i) in rankedPlayers" :key="p.name">
              <td>{{ i + 1 }}</td>
              <td>{{ p.name }}</td>
              <td>{{ p.points }}</td>
              <td>{{ p.buchholz }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          tournament: { name: '', timeControl: 'Rápidas', rounds: 1 },
          participantsText: '',
          players: [],
          rounds: []
        }
      },
      computed: {
        rankedPlayers() {
          return [...this.players]
            .map(p => ({ ...p, buchholz: this.calcBuchholz(p) }))
            .sort((a, b) => b.points - a.points || b.buchholz - a.buchholz);
        }
      },
      methods: {
        shuffle(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
          return array;
        },
        startTournament() {
          this.players = this.participantsText
            .split('\n').map(p => p.trim()).filter(Boolean)
            .map(p => ({
              name: p,
              points: 0,
              hadBye: false,
              whites: 0,
              blacks: 0,
              lastColor: null,
              opponents: []
            }));
          this.rounds = [];
          this.generateNextRound();
          this.save();
        },

        generateNextRound() {
          if (this.rounds.length >= this.tournament.rounds) return;

          let sorted;

          if (this.rounds.length === 0) {
            // Primeira rodada → sorteio aleatório
            sorted = this.shuffle([...this.players]);
          } else {
            // Demais rodadas → ordena por pontos
            sorted = [...this.players].sort((a, b) => b.points - a.points);
          }
          const used = new Set();
          const games = [];

          // Bye
          if (sorted.length % 2 === 1) {
            const bye = [...sorted].reverse().find(p => !p.hadBye);
            bye.points += 1;
            bye.hadBye = true;
            bye.lastColor = null;
            used.add(bye.name);
            games.push({ white: bye.name, black: '—', bye: true });
          }

          for (let i = 0; i < sorted.length; i++) {
            const p1 = sorted[i];
            if (used.has(p1.name)) continue;

            let opponent = null;
            for (let j = i + 1; j < sorted.length; j++) {
              const p2 = sorted[j];
              if (used.has(p2.name)) continue;
              if (!p1.opponents.includes(p2.name)) {
                opponent = p2;
                break;
              }
            }
            if (!opponent) continue;

            // Regras de cor
            let white = p1;
            let black = opponent;

            // Evitar mesma cor consecutiva
            if (p1.lastColor === 'white' && opponent.lastColor !== 'white') {
              white = opponent; black = p1;
            } else if (p1.lastColor === 'black' && opponent.lastColor !== 'black') {
              white = p1; black = opponent;
            }

            // Balanceamento geral
            if (white.whites > white.blacks) [white, black] = [black, white];

            white.whites++;
            black.blacks++;
            white.lastColor = 'white';
            black.lastColor = 'black';

            white.opponents.push(black.name);
            black.opponents.push(white.name);

            used.add(white.name);
            used.add(black.name);

            games.push({ white: white.name, black: black.name, result: '', bye: false });
          }

          this.rounds.push({ games });
          this.save();
        },

        applyResult(game) {
          if (game._applied || game.bye) return;

          const w = this.players.find(p => p.name === game.white);
          const b = this.players.find(p => p.name === game.black);

          if (game.result === '1-0') w.points += 1;
          if (game.result === '0-1') b.points += 1;
          if (game.result === '0.5-0.5') { w.points += 0.5; b.points += 0.5; }

          game._applied = true;

          const round = this.rounds[this.rounds.length - 1];
          const finished = round.games.filter(g => !g.bye).every(g => g.result);

          if (finished) this.generateNextRound();
          this.save();
        },

        calcBuchholz(player) {
          return player.opponents
            .map(o => this.players.find(p => p.name === o)?.points || 0)
            .reduce((a, b) => a + b, 0);
        },

        exportCSV() {
          let csv = 'Rodada,Brancas,Pretas,Resultado\n';
          this.rounds.forEach((r, i) => r.games.forEach(g => {
            csv += `${i + 1},${g.white},${g.black},${g.result || 'BYE'}\n`;
          }));
          const blob = new Blob([csv], { type: 'text/csv' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `${this.tournament.name || 'torneio'}.csv`;
          a.click();
        },

        save() {
          localStorage.setItem('chessTournament', JSON.stringify(this.$data));
        },

        load() {
          const d = localStorage.getItem('chessTournament');
          if (d) Object.assign(this.$data, JSON.parse(d));
        },

        resetTournament() {
          localStorage.removeItem('chessTournament');
          location.reload();
        }
      },
      mounted() { this.load(); }
    }).mount('#app');
  </script>

</body>

</html>